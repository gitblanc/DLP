<!DOCTYPE html>
<!-- saved from url=(0072) -->
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Acciones en ANTLR4. Listas.md</title>


    <style>
        /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

        body {
            font-family: "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
            font-size: 14px;
            padding: 0 12px;
            line-height: 22px;
            word-wrap: break-word;
        }

        #code-csp-warning {
            position: fixed;
            top: 0;
            right: 0;
            color: white;
            margin: 16px;
            text-align: center;
            font-size: 12px;
            font-family: sans-serif;
            background-color: #444444;
            cursor: pointer;
            padding: 6px;
            box-shadow: 1px 1px 1px rgba(0, 0, 0, .25);
        }

        #code-csp-warning:hover {
            text-decoration: none;
            background-color: #007acc;
            box-shadow: 2px 2px 2px rgba(0, 0, 0, .25);
        }


        body.scrollBeyondLastLine {
            margin-bottom: calc(100vh - 22px);
        }

        body.showEditorSelection .code-line {
            position: relative;
        }

        body.showEditorSelection .code-active-line:before,
        body.showEditorSelection .code-line:hover:before {
            content: "";
            display: block;
            position: absolute;
            top: 0;
            left: -12px;
            height: 100%;
        }

        body.showEditorSelection li.code-active-line:before,
        body.showEditorSelection li.code-line:hover:before {
            left: -30px;
        }

        .vscode-light.showEditorSelection .code-active-line:before {
            border-left: 3px solid rgba(0, 0, 0, 0.15);
        }

        .vscode-light.showEditorSelection .code-line:hover:before {
            border-left: 3px solid rgba(0, 0, 0, 0.40);
        }

        .vscode-dark.showEditorSelection .code-active-line:before {
            border-left: 3px solid rgba(255, 255, 255, 0.4);
        }

        .vscode-dark.showEditorSelection .code-line:hover:before {
            border-left: 3px solid rgba(255, 255, 255, 0.60);
        }

        .vscode-high-contrast.showEditorSelection .code-active-line:before {
            border-left: 3px solid rgba(255, 160, 0, 0.7);
        }

        .vscode-high-contrast.showEditorSelection .code-line:hover:before {
            border-left: 3px solid rgba(255, 160, 0, 1);
        }

        img {
            max-width: 100%;
            max-height: 100%;
        }

        a {
            color: #4080D0;
            text-decoration: none;
        }

        a:focus,
        input:focus,
        select:focus,
        textarea:focus {
            outline: 1px solid -webkit-focus-ring-color;
            outline-offset: -1px;
        }

        hr {
            border: 0;
            height: 2px;
            border-bottom: 2px solid;
        }

        h1 {
            padding-bottom: 0.3em;
            line-height: 1.2;
            border-bottom-width: 1px;
            border-bottom-style: solid;
        }

        h1,
        h2,
        h3 {
            font-weight: normal;
        }

        h1 code,
        h2 code,
        h3 code,
        h4 code,
        h5 code,
        h6 code {
            font-size: inherit;
            line-height: auto;
        }

        a:hover {
            color: #4080D0;
            text-decoration: underline;
        }

        table {
            border-collapse: collapse;
        }

        table>thead>tr>th {
            text-align: left;
            border-bottom: 1px solid;
        }

        table>thead>tr>th,
        table>thead>tr>td,
        table>tbody>tr>th,
        table>tbody>tr>td {
            padding: 5px 10px;
        }

        table>tbody>tr+tr>td {
            border-top: 1px solid;
        }

        blockquote {
            margin: 0 7px 0 5px;
            padding: 0 16px 0 10px;
            border-left: 5px solid;
        }

        code {
            font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
            font-size: 14px;
            line-height: 19px;
        }

        body.wordWrap pre {
            white-space: pre-wrap;
        }

        .mac code {
            font-size: 12px;
            line-height: 18px;
        }

        pre:not(.hljs),
        pre.hljs code>div {
            padding: 16px;
            border-radius: 3px;
            overflow: auto;
        }

        /** Theming */

        .vscode-light,
        .vscode-light pre code {
            color: rgb(30, 30, 30);
        }

        .vscode-dark,
        .vscode-dark pre code {
            color: #DDD;
        }

        .vscode-high-contrast,
        .vscode-high-contrast pre code {
            color: white;
        }

        .vscode-light code {
            color: #A31515;
        }

        .vscode-dark code {
            color: #D7BA7D;
        }

        .vscode-light pre:not(.hljs),
        .vscode-light code>div {
            background-color: rgba(220, 220, 220, 0.4);
        }

        .vscode-dark pre:not(.hljs),
        .vscode-dark code>div {
            background-color: rgba(10, 10, 10, 0.4);
        }

        .vscode-high-contrast pre:not(.hljs),
        .vscode-high-contrast code>div {
            background-color: rgb(0, 0, 0);
        }

        .vscode-high-contrast h1 {
            border-color: rgb(0, 0, 0);
        }

        .vscode-light table>thead>tr>th {
            border-color: rgba(0, 0, 0, 0.69);
        }

        .vscode-dark table>thead>tr>th {
            border-color: rgba(255, 255, 255, 0.69);
        }

        .vscode-light h1,
        .vscode-light hr,
        .vscode-light table>tbody>tr+tr>td {
            border-color: rgba(0, 0, 0, 0.18);
        }

        .vscode-dark h1,
        .vscode-dark hr,
        .vscode-dark table>tbody>tr+tr>td {
            border-color: rgba(255, 255, 255, 0.18);
        }

        .vscode-light blockquote,
        .vscode-dark blockquote {
            background: rgba(127, 127, 127, 0.1);
            border-color: rgba(0, 122, 204, 0.5);
        }

        .vscode-high-contrast blockquote {
            background: transparent;
            border-color: #fff;
        }
    </style>

    <style>
        /* Tomorrow Theme */
        /* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
        /* Original theme - https://github.com/chriskempson/tomorrow-theme */

        /* Tomorrow Comment */
        .hljs-comment,
        .hljs-quote {
            color: #8e908c;
        }

        /* Tomorrow Red */
        .hljs-variable,
        .hljs-template-variable,
        .hljs-tag,
        .hljs-name,
        .hljs-selector-id,
        .hljs-selector-class,
        .hljs-regexp,
        .hljs-deletion {
            color: #c82829;
        }

        /* Tomorrow Orange */
        .hljs-number,
        .hljs-built_in,
        .hljs-builtin-name,
        .hljs-literal,
        .hljs-type,
        .hljs-params,
        .hljs-meta,
        .hljs-link {
            color: #f5871f;
        }

        /* Tomorrow Yellow */
        .hljs-attribute {
            color: #eab700;
        }

        /* Tomorrow Green */
        .hljs-string,
        .hljs-symbol,
        .hljs-bullet,
        .hljs-addition {
            color: #718c00;
        }

        /* Tomorrow Blue */
        .hljs-title,
        .hljs-section {
            color: #4271ae;
        }

        /* Tomorrow Purple */
        .hljs-keyword,
        .hljs-selector-tag {
            color: #8959a8;
        }

        .hljs {
            display: block;
            overflow-x: auto;
            color: #4d4d4c;
            padding: 0.5em;
        }

        .hljs-emphasis {
            font-style: italic;
        }

        .hljs-strong {
            font-weight: bold;
        }
    </style>

    <style>
        /*
 * Markdown PDF CSS
 */

        body {
            font-family: "Meiryo", "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
        }

        pre {
            background-color: #f8f8f8;
            border: 1px solid #cccccc;
            border-radius: 3px;
            overflow-x: auto;
            white-space: pre-wrap;
            overflow-wrap: break-word;
        }

        pre:not(.hljs) {
            padding: 23px;
            line-height: 19px;
        }

        blockquote {
            background: rgba(127, 127, 127, 0.1);
            border-color: rgba(0, 122, 204, 0.5);
        }

        .emoji {
            height: 1.4em;
        }

        /* for inline code */
        :not(pre):not(.hljs)>code {
            color: #C9AE75;
            /* Change the old color so it seems less like an error */
            font-size: inherit;
        }

        /* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
        .page {
            page-break-after: always;
        }
    </style>


</head>

<body>
    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
                ? 'dark'
                : 'default'
        });
    </script>
    <p>Documento realizado para la asignatura de <em>Diseño de Lenguajes de Programación</em> de la <em>Escuela de Ingeniería Informática</em> de la <em>Universidad de Oviedo</em>.</p>
    <p>Raúl Izquierdo Castanedo (raul@uniovi.es)</p>
    <h1 id="operadores-de-repetici%C3%B3n-y-en-antlr4-v11">Operadores de Repetición (<code>+</code> y <code>*</code>) en ANTLR4 (v1.1)</h1>
    <!-- TOC -->
    <ul>
        <li><a href="#introducci%C3%B3n">Introducción</a></li>
        <li><a href="#conclusiones-sobre-la-creaci%C3%B3n-de-listas-java-en-antlr">Conclusiones sobre la Creación de Listas Java en ANTLR</a>
            <ul>
                <li><a href="#soluci%C3%B3n-con-regla-auxiliar">Solución con Regla Auxiliar</a></li>
                <li><a href="#soluci%C3%B3n-con-creaci%C3%B3n-autom%C3%A1tica-de-listas-operador-">Solución con Creación Automática de Listas (operador <code>+=</code>)</a></li>
            </ul>
        </li>
        <li><a href="#valores-obtenidos-de-los-operadores--y--en-java">Valores obtenidos de los operadores <code>+</code> y <code>*</code> en Java</a>
            <ul>
                <li><a href="#valor-obtenido-en-tokens-con-">Valor obtenido en Tokens con <code>+</code></a></li>
                <li><a href="#valor-obtenido-en-tokens-con-">Valor obtenido en Tokens con <code>*</code></a></li>
                <li><a href="#valor-obtenido-en-no-terminales-con-">Valor obtenido en No-Terminales con <code>+</code></a></li>
                <li><a href="#valor-obtenido-en-no-terminales-con-">Valor obtenido en No-Terminales con <code>*</code></a></li>
            </ul>
        </li>
        <li><a href="#opciones-de-implementaci%C3%B3n-de-reglas-de-repetici%C3%B3n">Opciones de Implementación de Reglas de Repetición</a>
            <ul>
                <li><a href="#gram%C3%A1tica-de-ejemplo">Gramática de Ejemplo</a></li>
                <li><a href="#caso-1-repetici%C3%B3n-en-el-padre">Caso 1. Repetición en el Padre</a>
                    <ul>
                        <li><a href="#insertar-los-hijos-individualmente">Insertar los Hijos Individualmente</a></li>
                        <li><a href="#usar-lista-local">Usar Lista Local</a></li>
                        <li><a href="#que-antlr-haga-la-lista-autom%C3%A1ticamente-operador-">Que ANTLR haga la lista automáticamente (operador <code>+=</code>)</a></li>
                    </ul>
                </li>
                <li><a href="#caso-2-repetici%C3%B3n-en-el-hijo">Caso 2. Repetición en el hijo</a></li>
                <li><a href="#caso-3-introducir-regla-intermedia">Caso 3. Introducir Regla Intermedia</a></li>
                <li><a href="#caso-4-opcionalidad-en-las-repeticiones-0cs">Caso 4. Opcionalidad en las repeticiones 0+cs</a></li>
                <li><a href="#comparativa-de-las-soluciones-estudiadas">Comparativa de las Soluciones Estudiadas</a></li>
            </ul>
        </li>
    </ul>
    <!-- /TOC -->
    <h2 id="introducci%C3%B3n">Introducción</h2>
    <blockquote>
        <p><strong>Importante</strong>. Para leer este documento, es requisito haber leído el documento "<em>Acciones en ANTLR4. Conceptos Básicos</em>".</p>
    </blockquote>
    <p>El siguiente apartado, <a href="#conclusiones-sobre-la-creaci%C3%B3n-de-listas-java-en-antlr">Conclusiones sobre la Creación de Listas Java en ANTLR</a>, debería estar situado al final del documento. En realidad, por donde se debería empezar es por entender los <a href="#valores-obtenidos-de-los-operadores--y--en-java">Valores obtenidos de los operadores <code>+</code> y <code>*</code> en Java</a> para luego proceder a valorar las <a href="#opciones-de-implementaci%C3%B3n-de-reglas-de-repetici%C3%B3n">opciones de Implementación de Reglas de Repetición</a>. Sin embargo, se ponen estas conclusiones delante para aquel alumno que quiera aprender de forma <em>rápida</em> como implementar las listas sin tener que leer <em>todo el documento</em>.</p>
    <p>El resto de las secciones son de lectura <em>opcional</em> y se incluyen para aquellos alumnos:</p>
    <ul>
        <li>Que quieran saber más detalles sobre el por qué de esas conclusiones.</li>
        <li>Tengan hecha su propia solución (la cual, probablemente, sea alguna de las <a href="#opciones-de-implementaci%C3%B3n-de-reglas-de-repetici%C3%B3n">opciones de Implementación de Reglas de Repetición</a>) y quieran saber sus ventajas e inconvenientes frente a las dos propuestas aquí.</li>
    </ul>
    <h2 id="conclusiones-sobre-la-creaci%C3%B3n-de-listas-java-en-antlr">Conclusiones sobre la Creación de Listas Java en ANTLR</h2>
    <p>La conclusión de este documento es que, a la hora de implementar una repetición en la gramática, se recomiendan estas dos opciones:</p>
    <ul>
        <li>Utilizar una Regla Auxiliar.</li>
        <li>Utilizar el operador <code>+=</code>.</li>
    </ul>
    <p>De entre estas dos soluciones, se deja a elección del alumno cuál de ellas utilizar.</p>
    <h3 id="soluci%C3%B3n-con-regla-auxiliar">Solución con Regla Auxiliar</h3>
    <p>Supóngase que se quiere indicar que un programa está formado por varias <em>sentencias</em>. La solución basada en incorporar una regla auxiliar consiste en definir una regla <em>sólo para la repetición</em> (<code>sentences</code>) que se encarga de crear la lista e introducir los elementos.</p>
    <pre class="hljs"><code><div>start returns[Program ast]
	: 'CODE' sentences { $ast = new Program($sentences.list); }
	;

sentences returns[List&lt;Sentence&gt; list = new ArrayList&lt;Sentence&gt;()]
	: (sentence { $list.add($sentence.ast); })*
	;

sentence returns[Sentence ast]
	: 'print' expr ';'	{ $ast = new Print($expr.ast); }
	| l=expr '=' r=expr ';'	{ $ast = new Assignment($l.ast, $r.ast); }
	;
</div></code></pre>
    <p>Lo que consigue la regla auxiliar es que la regla <em>padre</em> y el <em>elemento</em> a repetir (<code>start</code> y <code>sentence</code> respectivamente) sean simples <em>secuencias</em> que <em>no tengan que tratar</em> con la repetición. El tipo de repetición a usar (0/1+ss/cs) queda únicamente definido en la regla auxiliar.</p>
    <p>Esta solución es la que se corresponde con la tratada en <a href="#caso-3-introducir-regla-intermedia">Caso 3. Introducir Regla Intermedia</a>.</p>
    <h3 id="soluci%C3%B3n-con-creaci%C3%B3n-autom%C3%A1tica-de-listas-operador">Solución con Creación Automática de Listas (operador <code>+=</code>)</h3>
    <p>Al usar la opción de poner una etiqueta para dar nombre a un símbolo, se puede poner detrás de esta <code>+=</code> en vez de un <code>=</code>. La diferencia es que, de esta manera, ANTLR crea una lista del tipo adecuado (Token, si es un terminal, o su clase Context, si es un no-terminal) y añade automáticamente a la misma los tokens/contextos de los símbolos que se vayan repitiendo.</p>
    <p>En el siguiente ejemplo, <code>v</code> sería una lista de <code>ExprContext</code> (el contexto de <code>expr</code>). Cada uno de los elementos de dicha lista tendría el atributo <code>ast</code> con el valor de retorno de cada <code>expr</code>:</p>
    <pre class="hljs"><code><div>a: v+=expr (',' v+=expr)*
        { for (ExprContext ctx : $v) { System.out.println(ctx.ast); }};
</div></code></pre>
    <p>Usando esto, se podría hacer el mismo ejemplo del apartado anterior sin necesidad de la regla auxiliar <code>sentences</code>:</p>
    <pre class="hljs"><code><div>start returns[Program ast]
	: 'CODE' v+=sentence* { $ast = new Program($v); }
	;

sentence returns[Sentence ast]
	: 'print' expr ';'	{ $ast = new Print($expr.ast); }
	| l=expr '=' r=expr ';'	{ $ast = new Assignment($l, $r); }
	;
</div></code></pre>
    <p>La lista que ANTLR ha creado es de objetos <code>SentenceContext</code>, por lo que, antes de meterla en el AST, habría que recorrer dicha lista y extraer el atributo <code>ast</code> de cada elemento para dejarlo en una nueva <code>List&lt;Sentence&gt;</code>. En el ejemplo anterior se está suponiendo que esto lo hará el constructor de <em>Program</em> (esto se puede hacer a mano o bien usar <em>VGen</em>, el cual ya genera dicho código en los constructores).</p>
    <p>Esta opción tiene las siguientes ventajas:</p>
    <ul>
        <li>Es la solución con <em>menos reglas</em>: no hay reglas para las repeticiones.</li>
        <li>Es la <em>más límpia</em>: cada regla sólo tiene una acción y siempre al final (no entre los símbolos de la regla).</li>
    </ul>
    <p>Esta solución es la que se corresponde con la tratada en <a href="#que-antlr-haga-la-lista-autom%C3%A1ticamente-operador-">Que ANTLR haga la lista automáticamente (operador <code>+=</code>)</a>.</p>
    <blockquote>
        <p>OJO: si la regla tiene varias alternativas, no se puede usar el mismo nombre de lista si cada lista es de distintos tipos de elementos:</p>
        <pre class="hljs"><code><div>e:  v+=IDENT*    // v aquíe es List&lt;Token&gt;
   | v+=expr*  // v aquí es List&lt;AST&gt; --&gt; ERROR. Usar aquí otra etiqueta en vez de `v`
</div></code></pre>
    </blockquote>
    <h2 id="valores-obtenidos-de-los-operadores-y-en-java">Valores obtenidos de los operadores <code>+</code> y <code>*</code> en Java</h2>
    <p>Antes de plantear las distintas opciones para incorporar las acciones en Java que construyan el AST (apartado <a href="#opciones-de-implementaci%C3%B3n-de-reglas-de-repetici%C3%B3n">Opciones de Implementación de Reglas de Repetición</a>), hay que tener claro cómo funcionan los operadores <code>+</code> y <code>*</code>. Esto es lo que se tratará en detalle en este apartado y este es el <em>verdadero inicio</em> del documento (si se quieren saber los detalles).</p>
    <p>Cuando desde Java se acceder a un símbolo al que se le haya aplicado alguno de estos dos operadores, el valor obtenido dependerá de que dicho símbolo sea un <em>token</em> o un <em>no-terminal</em>.</p>
    <h3 id="valor-obtenido-en-tokens-con">Valor obtenido en Tokens con <code>+</code></h3>
    <p>Si se accede a un token al que se le ha aplicado <code>+</code>, se está accediendo sólo al último token de la serie. Supóngase la siguiente entrada:</p>
    <pre class="hljs"><code><div>2 a b c 3
</div></code></pre>
    <p>La siguiente acción imprimiría el lexema <code>c</code>:</p>
    <pre class="hljs"><code><div>a: INT IDENT+ INT { System.out.println($IDENT.text); }; // Imprime "c"
</div></code></pre>
    <p>Si se quisieran obtener todos los <code>IDENT</code>, habría que mover la acción <em>dentro</em> del operador <code>+</code> para que se ejecute cada vez que se repite el elemento:</p>
    <pre class="hljs"><code><div>a: INT (IDENT { System.out.println($IDENT.text); })+ INT;
 // Imprime "a b c"
</div></code></pre>
    <p>Esto, sin embargo, hace que la regla sea más difícil de leer, ya que mezcla los símbolos de la regla con el código Java.</p>
    <p>Otra opción sería indicar a ANTLR que nos guarde automáticamente todos los tokens de la repetición en una lista (<code>List&lt;Token&gt;</code>) y que nos deje dicha lista en el contexto de la regla. Para ello, habría que poner, antes del token que se repite, el nombre que se le quiere dar a la lista seguido del operador <code>+=</code>.</p>
    <pre class="hljs"><code><div>a: INT ids+=IDENT+ INT { System.out.println($ids); } // ids es una List&lt;Token&gt;
</div></code></pre>
    <p>Si se quisiera acceder a cada uno de los elementos, se recorrería como cualquier <code>List</code> de Java. Por ejemplo:</p>
    <pre class="hljs"><code><div>a: INT ids+=IDENT+ INT
        { for (Token tok : $ids) { System.out.println(tok.getText()); }};
</div></code></pre>
    <p>Esta opción permite unas reglas más limpias al tener todo el código Java al final de las mismas (y no intercaladas entre los símbolos).</p>
    <h3 id="valor-obtenido-en-tokens-con">Valor obtenido en Tokens con <code>*</code></h3>
    <p>Si se accede a un token al que se le ha aplicado <code>*</code>, el valor obtenido será:</p>
    <ul>
        <li>Si se ha usado el operador <code>+=</code>, siempre devolverá una lista de Token (aunque esté vacía). Ver operador <code>+</code> en el apartado anterior.
            <pre class="hljs"><code><div>a: INT ids+=IDENT* INT // ids siempre será una List&lt;Token&gt;
</div></code></pre>
        </li>
        <li>Si no se ha usado <code>+=</code>, depende de cuántas veces se halle dicho elemento en la entrada:
            <pre class="hljs"><code><div>a: INT IDENT* INT // $IDENT puede ser null o Token
</div></code></pre>
            <ul>
                <li>Si hay <em>cero</em> elementos, el <code>*</code> se comporta igual que el operador <code>?</code> con los terminales (y, por tanto, <code>$IDENT</code> y <code>$IDENT.text</code> devuelven <code>null</code> y <code>$IDENT.getText()</code> lanza una excepción). Para mas información , ver "<em>Acciones en ANTLR4. Opcionalidad</em>".</li>
                <li>Si hay algún elememento en la entrada, el <code>*</code> se comporta igual que el operador <code>+</code> (y, por tanto, si no se quiere acceder sólo al último elemento, hay que poner la acción <em>dentro</em> del <code>*</code> o usar el operador <code>+=</code>).</li>
            </ul>
        </li>
    </ul>
    <h3 id="valor-obtenido-en-no-terminales-con">Valor obtenido en No-Terminales con <code>+</code></h3>
    <p>Si se accede a un no-terminal al que se le ha aplicado <code>+</code>, se está accediendo sólo al <em>contexto</em> del último elemento de la serie. Supóngase la siguiente entrada:</p>
    <pre class="hljs"><code><div>2 a b c 3
</div></code></pre>
    <p>La siguiente acción imprimiría el lexema <code>c</code>:</p>
    <pre class="hljs"><code><div>a: INT b+ INT { System.out.println($b.text); }; // Imprime "c"

b returns[String val]
	: IDENT { $val = $IDENT.text; };
</div></code></pre>
    <p>Si se quisieran obtener todos los valores devueltos por <code>a</code>, habría que mover la acción <em>dentro</em> del operador <code>+</code>, para que se ejecute así con cada elemento que se encuentre:</p>
    <pre class="hljs"><code><div>a: INT (b {System.out.println($b.val); })+ INT; // a b c
</div></code></pre>
    <p>Esto, sin embargo, hace que la regla sea más difícil de leer, ya que mezcla los símbolos de la regla con el código Java.</p>
    <p>Otra opción sería indicar a ANTLR que nos guarde automáticamente todos los contextos de los elementos de la repetición en una lista (<code>List&lt;ParserRuleContext&gt;</code>) y que nos deje dicha lista en el contexto de la regla actual. Para ello, habría que poner, antes del token que se repite, el nombre que se le quiere dar a la lista seguido del operador <code>+=</code>.</p>
    <pre class="hljs"><code><div>a: INT v+=b+ INT { System.out.println($v); } // `v` es una List&lt;BContext&gt;

b returns[String val]
	: IDENT { $val = $IDENT.text; };
</div></code></pre>
    <p>Si se quisiera acceder a cada uno de los elementos, se recorrería como cualquier <code>List</code> de Java. Por ejemplo:</p>
    <pre class="hljs"><code><div>a: INT v+=b+ INT { for (BContext ctx : $v) { System.out.println(ctx.val); } }
</div></code></pre>
    <blockquote>
        <p>OJO: si la regla tiene varias alternativas, no se puede usar el mismo nombre de lista si cada lista es de distintos tipos de elementos:</p>
        <pre class="hljs"><code><div>e:  v+=IDENT*    // v aquíe es List&lt;Token&gt;
   | v+=expr*  // v aquí es List&lt;AST&gt; --&gt; ERROR. Usar aquí otra etiqueta en vez de `v`
</div></code></pre>
    </blockquote>
    <h3 id="valor-obtenido-en-no-terminales-con">Valor obtenido en No-Terminales con <code>*</code></h3>
    <p>Si se accede a un no-terminal al que se le ha aplicado <code>*</code>, el valor obtenido será:</p>
    <ul>
        <li>Si se ha usado el operador <code>+=</code>, siempre devolverá una lista de contextos, aunque esté vacía (ver operador <code>+</code> en el apartado anterior).
            <pre class="hljs"><code><div>a: INT v+=b* INT // `v` siempre será una List&lt;BContext&gt;
</div></code></pre>
        </li>
        <li>Si no se ha usado <code>+=</code>, depende de cuántas veces se halle dicho elemento en la entrada:
            <pre class="hljs"><code><div>a: INT b* INT // $a.val puede lanzar excepción

b returns[String val]
    : IDENT { $val = $IDENT.text; };
</div></code></pre>
            <ul>
                <li>Si hay <em>cero</em> elementos, se comporta igual que el operador <code>?</code> con los no-terminales (y, por tanto, <code>$b.ctx</code> valdrá <code>null</code> y <code>$b.val</code> lanzará una excepción). Para mas información , ver "<em>Acciones en ANTLR4. Opcionalidad</em>".</li>
                <li>Si hay algún elememento en la entrada, se comporta igual que el operador <code>+</code> (y, por tanto, si no se quiere acceder sólo al último elemento, hay que poner la acción <em>dentro</em> del <code>*</code> o usar el operador <code>+=</code>).</li>
            </ul>
        </li>
    </ul>
    <h2 id="opciones-de-implementaci%C3%B3n-de-reglas-de-repetici%C3%B3n">Opciones de Implementación de Reglas de Repetición</h2>
    <p>Una vez vistos todos los posibles valores que puede devolver un símbolo al que se le haya aplicado el operador <code>+</code> o <code>*</code>, se verán a continuacion las opciones disponibles a la hora de añadir las acciones Java a las reglas que expresen <em>repetición de elementos</em>. Los cuatro tipos de repeticiones que se encontrarán son:</p>
    <ul>
        <li>Uno o más elementos sin separadores (1+ss)</li>
        <li>Cero o más elementos sin separadores (0+ss)</li>
        <li>Uno o más elementos con separadores (1+cs)</li>
        <li>Cero o más elementos con separadores (0+cs)</li>
    </ul>
    <p>En cada solución posterior se estudiarán sólo las versiones 0+ss y 0+ss ya que, si no se dice lo contrario, las otras dos versiones serán similares en cuanto a las acciones a añadir.</p>
    <h3 id="gram%C3%A1tica-de-ejemplo">Gramática de Ejemplo</h3>
    <p>Como gramática de ejemplo a utilizar en todas las soluciones, supóngase que se tienen dos no-terminales <code>n</code> y <code>e</code>. Para este documento la composición de <code>e</code> no es relevante (podría ser cualquier combinación de tokens y/o no-terminales). Pero para <code>n</code>, se quiere indicar que empieza por una <code>a</code>, la siguen varios <code>e</code> y acaba en una <code>b</code>.</p>
    <p>En función de en qué regla se ponga la repetición, hay las siguientes opciones:</p>
    <ol>
        <li>
            <p>Poner la repetición (operador <code>*</code>) en el padre <code>n</code> (caso 1).</p>
            <pre class="hljs"><code><div>n: a e* b

e: x y z
</div></code></pre>
        </li>
        <li>
            <p>Poner la repetición en el hijo <code>e</code> (caso 2).</p>
            <pre class="hljs"><code><div>n: a e b

e: (x y z)*
</div></code></pre>
        </li>
        <li>
            <p>Poner la repetición en una regla intermedia a la que se llamará <code>es</code> (caso 3).</p>
            <pre class="hljs"><code><div>n: a es b

es: e*

e: x y z
</div></code></pre>
        </li>
    </ol>
    <p>Además, en el caso particular de las repeticiones 0+cs, se presentan dos formas de plantear la opcionalidad (caso 4):</p>
    <ol>
        <li>
            <p>Con la opcionalidad junto con la repetición.</p>
            <pre class="hljs"><code><div>n: a es b

es: (e (s e)*)?

e: x y z
</div></code></pre>
        </li>
        <li>
            <p>Con la opcionalidad en el padre.</p>
            <pre class="hljs"><code><div>n: a es? b

es: e (s e)*

e: x y z
</div></code></pre>
        </li>
    </ol>
    <p>A continuación, se verán las ventajas e inconvenientes de todas estas opciones a la hora de introducir en las reglas las acciones en Java que creen el AST. Para ello, supóngase que en las reglas <code>n</code> y <code>e</code> se quiere crear objetos de las clases <code>NNode</code> y <code>ENode</code>.</p>
    <pre class="hljs"><code><div>n returns [NNode ast]: ...  { $ast = new NNode(...); }

e returns [ENode ast]: ...  { $ast = new ENode(...); }
</div></code></pre>
    <h3 id="caso-1-repetici%C3%B3n-en-el-padre">Caso 1. Repetición en el Padre</h3>
    <p>Si la repetición se indica en el padre, se tienen los dos siguientes casos en función de que sea 0+ss o 0+cs.</p>
    <pre class="hljs"><code><div>// 0+ss
n: a e* b

e: ...
</div></code></pre>
    <pre class="hljs"><code><div>// 0+cs
n: a (e (',' e)*)? b

e: ...
</div></code></pre>
    <p>Se muestran a continuación las opciones a la hora de insertar las acciones en estas situaciones.</p>
    <h4 id="insertar-los-hijos-individualmente">Insertar los Hijos Individualmente</h4>
    <p>En esta solución, el nodo, en vez de crearse de la manera habitual al final de la regla con el clásico "<code>$ast = new...</code>", se crea ya en la cláusila <code>returns</code>. Los hijos se van metiendo después en el <code>NNode</code> segun van apareciendo.</p>
    <p>Para mostrar esta solución, se van a quitar los no-terminales <code>a</code> y <code>b</code> de la regla "<code>n: a e* b</code>" para dejarla en "<code>n: e*</code>", ya que de otra manera complican el ejemplo.</p>
    <p>La versión 0+ss sería:</p>
    <pre class="hljs"><code><div>n returns [NNode ast = new NNode()]
    : (e { $ast.addChild($e.ast); })* ;

e returns [ENode ast]: ...
</div></code></pre>
    <p>La versión 0+cs sería:</p>
    <pre class="hljs"><code><div>n returns [NNode ast = new NNode()]
    : (e { $ast.addChild($e.ast); } (',' e { $ast.addChild($e.ast); })*)? ;

e returns [ENode ast]: ...
</div></code></pre>
    <p>Consideraciones de esta opción:</p>
    <ul>
        <li>Esta solución requiere que el nodo padre tenga un método que permita añadir los hijos de uno en uno (<code>addChild</code>) por cada hijo que tenga con repeticiones. Eso supone además que, a la hora de calcular la posición del padre en el fichero, será necesario que dicho método <code>addChild</code> actualice las posiciones del padre a medida que le añadan hijos.</li>
        <li>Esta solución se complica si, además de los elementos a repetir <code>e</code>, hay símbolos adicionales (<code>a</code> y <code>b</code>), ya que habrá que añadir métodos también para añadir dichos hijos e intercalar en la regla las acciones que los añadan al padre.</li>
        <li>El hecho de que los hijos no se añadan a la vez, supone que:
            <ul>
                <li>El objeto estará en un estado inválido hasta que se pasen todos los hijos (el constructor no podrá cumplir dicha misión).</li>
                <li>No permitirá objetos que, al crearse, necesite tener todos los hijos a la vez para realizar algún tipo de inicialización u operación a partir de éstos.</li>
            </ul>
        </li>
        <li>Al insertar una acción en mitad de la regla, añade <em>ruido</em> que dificulta identificar la esencia de la regla (el <code>a e* b</code>). Este <em>ruido</em> aumenta en el caso de las versiones con separadores.</li>
        <li>Esta solución no es válida si <code>n</code> tuviera otras alternativas que necesitarán devolver distintos objetos, ya que el <code>new</code> no va en cada regla.</li>
    </ul>
    <h4 id="usar-lista-local">Usar Lista Local</h4>
    <p>En esta solución se hará uso de una lista local donde se guardarán los <code>ENode</code> para luego pasárselos todos juntos al <code>NNode</code>.</p>
    <p>La versión 0+ss sería:</p>
    <pre class="hljs"><code><div>n returns [NNode ast]
  locals[List&lt;ENode&gt; list = new ArrayList&lt;ENode&gt;()]
    : a (e { $list.add(e.ast) })* b   { $ast = new NNode($a.ast, $list, $b.ast); };

e returns [ENode ast]: ...
</div></code></pre>
    <p>La versión 0+cs sería:</p>
    <pre class="hljs"><code><div>n returns [NNode ast]
  locals[List&lt;ENode&gt; list = new ArrayList&lt;ENode&gt;()]
    : a (e { $list.add($e.ast); } (',' e { $list.add($e.ast); })*)? b
        { $ast = new NNode($a.ast, $list, $b.ast); };

e returns [ENode ast]: ...
</div></code></pre>
    <p>Consideraciones de esta opción:</p>
    <ul>
        <li>Si la regla <code>n</code> tuviera más hijos con repeticiones o bien más alternativas (<code>n: ...|...</code>) en las que también hubiera hijos con repeticiones, se complicaría la sección <code>locals</code> al tener que definir listas para cada uno de estos hijos.</li>
        <li>El requerir la cláusula <code>locals</code> e insertar una acción en mitad de la regla (<code>$list.add(...)</code>), añade cierto <em>ruido</em> que dificulta identificar la esencia de la regla (el <code>a e* b</code>). Este <em>ruido</em> aumentaría si hubiera más hijos con repeticiones (en la misma regla o en alternativas) y, especialmente, en el caso de la versión con separadores.</li>
    </ul>
    <h4 id="que-antlr-haga-la-lista-autom%C3%A1ticamente-operador">Que ANTLR haga la lista automáticamente (operador <code>+=</code>)</h4>
    <p>En los casos anteriores, se hacía la lista a mano. Sin embargo, como ya se ha visto, se le puede decir a ANTLR4 que haga la lista por nosotros con el operador <code>+=</code>.</p>
    <p>La versión 0+ss con esta solución quedaría así:</p>
    <pre class="hljs"><code><div>n returns [NNode ast]
    : a v+=e* b
        {   List&lt;ENode&gt; list = new ArrayList&lt;ENode&gt;();
            for (ExprContext ctx : $v)
                list.add(ctx.ast);
            $ast = new NNode($a.ast, list, $b);
        }

e: ...
</div></code></pre>
    <p>El operador <code>+=</code> tiene la ventaja de que la regla, en vez de estar entre los símbolos de la gramática, va al final de la misma permitiendo una lectura más sencilla de la misma.</p>
    <p>Sin embargo, si se opta por esta opción, es más limpio todavía incorporar el bucle <code>for</code> anterior dentro del constructor de <code>NNode</code> y se conseguiría la gramática más limpia posible:</p>
    <pre class="hljs"><code><div>n returns [NNode ast]
    : a v+=e* b   { $ast = new NNode($a.ast, $v, $b.ast); }
</div></code></pre>
    <p>Si se usa VGen, se obtendrán constructores en todos los nodos que hacen automáticamente este proceso (ver Tutorial).</p>
    <p>La versión 0+cs sería:</p>
    <pre class="hljs"><code><div>n returns [NNode ast]
    : a (v+=e (',' v+=e)*)? b   { $ast = new NNode($a.ast, $v, $b); }
</div></code></pre>
    <p>Lo siguiente es un ejemplo de la aplicación de esta solución a una regla (<code>start</code>) que tiene dos hijos que se pueden repetir 0+ss (<code>variable</code> y <code>sentence</code>):</p>
    <pre class="hljs"><code><div>start returns[Program ast]
	: 'DATA' vv+=variable* 'CODE' vs+=sentence* EOF { $ast = new Program($vv, $vs); }
	;

variable returns[VarDefinition ast]
	: tipo IDENT ';' { $ast = new VarDefinition($tipo.ast, $IDENT.text); }
	;

sentence returns[Sentence ast]
	: 'print' expr ';'	{ $ast = new Print($expr.ast); }
	| l=expr '=' r=expr ';'	{ $ast = new Assignment($l.ast, $r.ast); }
	;
</div></code></pre>
    <p>Consideraciones de esta opción:</p>
    <ul>
        <li>Es la solución que requiere menos reglas, ya que solo quedarán la <em>secuencias</em> y las <em>composiciones</em> (no habrá reglas para expresar <em>listas</em>).</li>
        <li>Permite unas reglas más limpias al tener todo el código Java al final de las mismas (y no intercaladas entre los símbolos).</li>
        <li>El usar la versión de 0+cs, al contrario de lo que ocurre con otras soluciones, apenas oscurece la regla, siendo la versión más compacta de todas.</li>
        <li>Requiere añadir el bucle que extraiga los hijos de la lista de contextos que crea ANTLR. Sin embargo, si se usa VGen, ese código ya se genera automáticamente.</li>
    </ul>
    <h3 id="caso-2-repetici%C3%B3n-en-el-hijo">Caso 2. Repetición en el hijo</h3>
    <p>Si la repetición se indica en el hijo, se tienen los dos siguientes casos en función de que sea 0+ss o 0+cs.</p>
    <pre class="hljs"><code><div>// 0+ss
n: a e b

e: (x y z)*
</div></code></pre>
    <pre class="hljs"><code><div>// 0+cs
n: a e b

e: (x y z (',' x y z)*)?
</div></code></pre>
    <p>En este caso, la única opción es que el símbolo <code>e</code> devuelva ya una <code>List&lt;ENode&gt;</code>.</p>
    <p>La versión 0+ss sería:</p>
    <pre class="hljs"><code><div>n returns [NNode ast]
    : a e b   { $ast = new NNode($a.ast, $e.list, $b.ast); }

e returns [List&lt;ENode&gt; list = new ArrayList&lt;Enode&gt;()]
    : (x y z { $list.add(new ENode($x.ast, $y.ast, $z.ast)); } )*
</div></code></pre>
    <p>Ejemplo de aplicación de esta solución:</p>
    <pre class="hljs"><code><div>structDeclaration returns[DefinicionStruct ast]
	: 'struct' IDENT '{' fields '}' ';' { $ast = new StructDef($IDENT, $fields.list); }
	;

fields returns[List&lt;Campo&gt; list = new ArrayList&lt;Campo&gt;()]
	: (IDENT ':' type ';' { $list.add(new Campo($IDENT, $type.ast)); })*
	;
</div></code></pre>
    <p>Supongase ahora que la regla <code>e</code> tuviera alternativas:</p>
    <pre class="hljs"><code><div>e: x y z | h j m | q w e
</div></code></pre>
    <p>En este caso, la solución actual se aplicaría asi:</p>
    <pre class="hljs"><code><div>n returns [NNode ast]
    : a e b   { $ast = new NNode($a.ast, $e.list, $b.ast); }

e returns [List&lt;ENode&gt; list = new ArrayList&lt;Enode&gt;()]
    : (
        x y z { $list.add(new ENode($x.ast, $y.ast, $z.ast)); }
        | h j m { $list.add(new ENode($h.ast, $j.ast, $m.ast)); }
        | q w e { $list.add(new ENode($q.ast, $w.ast, $e.ast)); }
      )*
</div></code></pre>
    <p>Ejemplo de aplicación de esta solución:</p>
    <pre class="hljs"><code><div>start returns[Programa ast]
	: declarations EOF { $ast = new Programa($declarations.list); }
	;

declarations returns[List&lt;Definicion&gt; list = new ArrayList&lt;Definicion&gt;()]
	: (
		structDeclaration		{ $list.add($structDeclaration.ast); }
		| globalVarDefinition	{ $list.add($globalVarDefinition.ast); }
		| functionDefinition	{ $list.add($functionDefinition.ast);}
	)*;
</div></code></pre>
    <p>La versión 0+cs sería, volviendo a la versión original en la que <code>e</code> tenía sólo una alternativa, la siguiente:</p>
    <pre class="hljs"><code><div>n returns [NNode ast]
    : a e b   { $ast = new NNode($a.ast, $e.list, $b.ast); }

e returns [List&lt;ENode&gt; list = new ArrayList&lt;Enode&gt;()]
    : (x y z { $list.add(new ENode($x.ast, $y.ast, $z.ast)); }
     (',' x y z { $list.add(new ENode($x.ast, $y.ast, $z.ast)); })* )?
</div></code></pre>
    <p>La versión 0+cs para <code>e</code> con varias alternativas no se incluye porque sería realmente confusa y se descarta directamente.</p>
    <p>Consideraciones finales de la opción de expresar la repetición en el hijo:</p>
    <ul>
        <li>Esta solución es aplicable sólo si <code>e</code> es siempre usado como parte de una repetición, ya que el símbolo <code>e</code> individual deja de estar definido (es decir, otra regla no puede usar <code>e</code> si quiere un solo elemento).</li>
        <li>En esta solución, la regla <code>e</code> mezcla tanto la propia definición de <code>e</code> (construcción <em>secuencia</em>) con la construción <em>lista</em>. Mezclar construcciones no es recomendable ya que, como puede comprobarse especialmente en la versión 0+cs, resulta en código repetido y definiciones recargadas.</li>
        <li>Esta solución no es práctica en las versiones con separadores.</li>
    </ul>
    <h3 id="caso-3-introducir-regla-intermedia">Caso 3. Introducir Regla Intermedia</h3>
    <p>Si se introduce una regla intermedia que se encarga de expresar la repetición, se tienen los dos siguientes casos en función de que sea 0+ss o 0+cs.</p>
    <pre class="hljs"><code><div>// 0+ss
n: a es b

es: e*

e: ...
</div></code></pre>
    <pre class="hljs"><code><div>// 0+cs
n: a es b

es: (e (',' e)*)?

e: ...
</div></code></pre>
    <p>La implementación para 0+ss sería:</p>
    <pre class="hljs"><code><div>n returns [NNode ast]
    : a es b   { $ast = new NNode($a.ast, $es.list, $b.ast); }

es returns [List&lt;ENode&gt; list = new ArrayList&lt;Enode&gt;()]
    : (e { $list.add($.ast); })*

e returns [ENode ast]: ...  { $ast = new ENode(...); }
</div></code></pre>
    <p>Ejemplo de aplicación de esta solución:</p>
    <pre class="hljs"><code><div>start returns[Programa ast]
	: declarations EOF { $ast = new Programa($declarations.list); }
	;

declarations returns[List&lt;Definicion&gt; list = new ArrayList&lt;Definicion&gt;()]
	: (declaration { $list.add($declaration.ast);})*
	;

declaration returns[Definicion ast]
	: structDeclaration     { $ast = $structDeclaration.ast; }
	| globalVarDefinition	{ $ast = $globalVarDefinition.ast; }
	| functionDefinition	{ $ast = $functionDefinition.ast; }
	;
</div></code></pre>
    <p>La versión 0+cs sería:</p>
    <pre class="hljs"><code><div>es returns [List&lt;ENode&gt; list = new ArrayList&lt;Enode&gt;()]
    : (e { $list.add($.ast); } (',' e { $list.add($.ast); })*)?
</div></code></pre>
    <p>Consideraciones de la opción de añadir una Regla Intermedia para expresar la repetición:</p>
    <ul>
        <li>Esta solución es la que más desacopla el tipo de repetición usado (de cero/uno o más y con/sin separadores) de las reglas padre e hija (<code>n</code> y <code>e</code>). Facilmente permitiría pasar de un tipo de repetición a otro sin afectar al resto de las reglas (ni <code>n</code> ni <code>e</code> habría que modificarlas).</li>
        <li>Esta solución hace que tanto la regla <code>n</code> como la <code>e</code> queden lo más límpias posibles (con una sola acción y al final de la regla). En general, con esta solución, <em>toda</em> regla que no sea una regla intermedia para repetición tendrá una sola acción y al final. Sólo las reglas intermedias tendrán acciones dentro de la regla (entre sus símbolos y operadores).</li>
        <li>Como resultado de lo anterior, esta solución facilita la comprensión de la gramática. Al ser las reglas intermedas para repetición las únicas que no tienen la acción al final, a la hora de estudiar la gramática, son fáciles de identificar e ignorar, centrándose así en las reglas relevantes de la misma (las que tienen la acción al final).</li>
        <li>Esta solución es la que más se parecería a una realizada en notación BNF. Para pasar de BNF a EBNF y viceversa solo habría que cambiar estas reglas intermedias. No habría que tocar las otras reglas.</li>
        <li>Sin embargo, el inconveniento obvio de esta solución es que hace que crezca el número de reglas de la gramática (tantas como construcciones <em>lista</em> haya).</li>
    </ul>
    <h3 id="caso-4-opcionalidad-en-las-repeticiones-0cs">Caso 4. Opcionalidad en las repeticiones 0+cs</h3>
    <p>Como se adelantó en la visión general, en el caso particular de las repeticiones 0+cs, se presentan dos formas de plantear la opcionalidad:</p>
    <ol>
        <li>
            <p>Con la opcionalidad junto con la repetición.</p>
            <pre class="hljs"><code><div>n: a es b

es: (e (s e)*)?

e: x y z
</div></code></pre>
        </li>
        <li>
            <p>Con la opcionalidad en el padre.</p>
            <pre class="hljs"><code><div>n: a es? b

es: e (s e)*

e: x y z
</div></code></pre>
        </li>
    </ol>
    <p>El primer caso es el que se ha estado usando en todos las soluciones anteriores, ya que es la opción recomendada.</p>
    <p>La segunda solución no se recomienda por los siguientes motivos:</p>
    <ul>
        <li>La construcción <em>repetición</em> queda dispersa entre las dos reglas. Se recomienda que sólo una regla se encarga de expresar el tipo de repetición necesario (si es 0+cs, que se vea directamente en una sola regla y no crear una regla 1+cs para luego hacerla opcional en otro sitio).</li>
        <li>Se complica la acción que crea el <code>NNode</code> en <code>n</code>. Dado que <code>es?</code> es opcional, si este no aparece a la entrada, el contexto de <code>$es</code> sería <code>null</code> y por tanto acceder a <code>$es.list</code> produciría un <code>NullPointerException</code>. Por tanto, la acción se complicaría ya que habría que contemplar dicho caso usando un <code>if</code> antes de acceder al retorno de la regla <code>es</code>. Para mas información , ver "<em>Acciones en ANTLR4. Opcionalidad</em>".</li>
    </ul>
    <h3 id="comparativa-de-las-soluciones-estudiadas">Comparativa de las Soluciones Estudiadas</h3>
    <p>A la hora de recomendar una opción, se tendrán en cuenta los objetivos de:</p>
    <ul>
        <li><strong>Minimizar</strong> el número de reglas de la gramática.</li>
        <li><strong>Maximizar</strong> la limpieza de las reglas. Una regla será más dificil de leer cuantas más acciones Java tenga y, especialmente, si están entre los símbolos de la regla.</li>
    </ul>
    <p>Por ello, si se usa VGen, se recomienda usar la solución de poner la repetición en el padre y <a href="#que-antlr-haga-la-lista-autom%C3%A1ticamente-operador-">que ANTLR haga la lista automáticamente (operador <code>+=</code>)</a>. Es la única que consigue los dos objetivos a la vez:</p>
    <ul>
        <li>El menor número de reglas posibles en la gramática (no hay reglas auxiliares para las listas).</li>
        <li>La mayor limpieza en las acciones, ya que cada regla sólo tendrá una acción (el <code>new</code>) y estará al final de la misma (lo que facilita la comprensión de la gramática).</li>
    </ul>
    <p>Si no se usa VGen (y no se quiere hacer en los constructores el código equivalente a mano), se recomienda la opción de <a href="#caso-3-introducir-regla-intermedia">Introducir Regla Intermedia</a>. Tiene inconvenientes frente a la solucion anterior:</p>
    <ul>
        <li>Requiere mayor número de reglas que la solución anterior (añade tantas reglas como listas haya).</li>
        <li>No consigue tanta limpieza en las reglas (las reglas de las listas tendrán acciones entre los símbolos)</li>
    </ul>
    <p>Sin embargo, es una solución sencilla de implementar y con una limpieza aceptable (las reglas que sean <em>secuencias</em> y <em>composiciones</em> - que son las reglas importantes - si tendrán una sóla acción y al final de la regla).</p>
    <p>El resto de las soluciones estudiadas no se recomiendan debido a que no consiguen alcanzar en la misma medida alguno o los dos objetivos anteriores:</p>
    <ul>
        <li>En cuanto a poner la repetición en el padre:
            <ul>
                <li>La opción de <a href="#insertar-los-hijos-individualmente">Insertar los Hijos Individualmente</a> no se recomienda, ya que requiere meter cada hijo por separado (incluso los que no se repiten). No vale, además, si el padre tiene varias reglas que requieran devolver distintos tipos de objetos.</li>
                <li>La opción de <a href="#usar-lista-local">Usar Lista Local</a> tampoco se recomienda, ya que produce reglas que, al menos, necesitarán dos acciones, lo cual producirá reglas menos limpias que con otras opciones.</li>
            </ul>
        </li>
        <li>En cuanto a la opción de <a href="#caso-2-repetici%C3%B3n-en-el-hijo">Repetición en el hijo</a>, no se recomienda por la poca limpieza que se obtiene en las reglas. Mezcla las definiciones de los elementos con la construcción de la lista. Sólo sería planteable si la repetición fuera sin separadores y si <code>e</code> no se usa en ningún otro sitio individualmente.</li>
    </ul>



</body>

</html>
